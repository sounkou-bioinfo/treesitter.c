---
output: github_document
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  out.width = "100%"
)
```
[![treesitter.c status badge](https://sounkou-bioinfo.r-universe.dev/treesitter.c/badges/version)](https://sounkou-bioinfo.r-universe.dev/treesitter.c)
[![CRAN](https://www.r-pkg.org/badges/version/treesitter.c)](https://CRAN.R-project.org/package=treesitter.c)

# treesitter.c

C grammar for the R treesitter package.

## Installation

```{r eval=FALSE}
# Install  the development version of treesitter.c from r-universe
install.packages('treesitter.c', repos = c('https://sounkou-bioinfo.r-universe.dev', 'https://cloud.r-project.org'))
# or the cran release
install.packages('treesitter.c', repos = 'https://cloud.r-project.org')
```

## Usage
```{r eval=TRUE}
library(treesitter)
library(treesitter.c)

c_language <- language()
parser <- parser(c_language)

code <- "
struct Point {
  int x[MAX_SIZE];
  int y;
};
"

tree <- parser_parse(parser, code)
tree
```


## Preprocessing and header parsing

If you have a C compiler available and want to preprocess macros (recommended for headers that use macros), enable `preprocess = TRUE`. Prefer to use the helper `r_cc()` to detect the compiler automatically

```{r eval=TRUE}
# Check for a compiler and use include_dirs so the preprocessor can find nested headers
cc <- treesitter.c::r_cc()
hdr_df_pp <- parse_r_include_headers(
    dir = R.home("include"),
    preprocess = TRUE,
    include_dirs = R.home("include")
  )
hdr_df_pp[grepl("Rf", x = hdr_df_pp$name), ] |> head(10)
```


You can use the `preprocess_header` function with extra compiler options to avoid system includes and use the bundled fake libc headers. This avoids system includes bloat.

```{r}
library(treesitter.c)

# Path to a header file to preprocess
header_file <- file.path(R.home("include"), "Rinternals.h")

# Get the path to the fake libc headers
fake_libc <- fake_libc_path()

# Preprocess with -nostdinc and -I pointing to fake_libc
preprocessed <- preprocess_header(
   file = header_file,
   cc = r_cc(),
    ccflags = paste0("-I", fake_libc),
  "-nostdinc"
)
cat(substr(preprocessed, 1, 500)) 
```

This approach ensures only the fake libc headers are used, making preprocessing more predictable and portable.


## Parsing examples

The following concise examples demonstrate extracting specific information (functions, parameters, structs, macros) using the package's simple helpers.

Simple parse and extract functions: parse a small header string and extract functions with parameter types.

```{r eval=TRUE}
txt <- "int foo(int a, const char* s);
static inline int bar(void) { return 1; }"
# extract params and return type
root <- parse_header_text(txt)
get_function_nodes(root, extract_params = TRUE, extract_return = TRUE)
get_function_nodes(root, extract_params = TRUE)


```


Extract function parameter and return types while parsing:

```{r eval=TRUE}
txt <- "int foo(int a, const char* s);"
root <- parse_header_text(txt)
get_function_nodes(root, extract_params = TRUE, extract_return = TRUE)
```


Get structs and members:

```{r eval=TRUE}
txt <- "struct T { unsigned int x:1; int y; };"
root <- parse_header_text(txt)
get_struct_nodes(root)
get_struct_members(root)
```
Collect a directory with all kinds using `parse_headers_collect`

```{r eval=TRUE}
res <- parse_headers_collect(dir = R.home("include"), preprocess = FALSE, extract_params = TRUE)
names(res)
head(res$functions)
# Optional: inspect macros from a single header
path <- file.path(R.home("include"), "Rembedded.h")
defs <- get_defines_from_file(path, use_cpp = TRUE, ccflags = paste("-I", dirname(path)))
  head(defs)
```

## Details On the Used Grammar

treesiter ABI Version 14, compatible with treesitter package version 0.3.0. The C grammar source used for bootstrapping was downloaded from https://github.com/tree-sitter/tree-sitter-c. The pre-generated `parser.c` from upstream is ~3.7 MB and contains pragma directives that trigger CRAN check warnings.

During bootstrap (`bootstrap.R`), all `#pragma` directives are automatically removed from `parser.c` to ensure CRAN compliance. This includes pragmas for diagnostic control and optimization settings that are not portable across compilers.

## License

GPL-3

## References

- [On parsing c type declarations and fake headers](https://eli.thegreenplace.net/2015/on-parsing-c-type-declarations-and-fake-headers)
